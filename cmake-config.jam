# Copyright 2018 Peter Dimov
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at http://boost.org/LICENSE_1_0.txt)

import modules ;
import boostcpp ;
import property-set ;
import "class" : new ;
import project ;
import common ;
import virtual-target ;
import print ;
import os ;
import cmake-config-dependencies ;
import feature ;

feature.feature library-type : : free ;

if "--debug-cmake-config" in [ modules.peek : ARGV ]
{
    .info-enabled = 1 ;
}

local rule .info ( messages * )
{
    if $(.info-enabled)
    {
        ECHO "info:" $(messages) ;
    }
}

# generate-cmake-variant-

rule generate-cmake-variant- ( target : sources * : properties * )
{
    .info generate-cmake-variant- $(target) ":" $(sources) ;

    local ps = [ property-set.create $(properties) ] ;

    print.output $(target) ;

    local version = [ $(ps).get <version> ] ;
    .info "  version=" $(version) ;

    local name = [ $(ps).get <name> ] ;
    .info "  name=" $(name) ;

    local variant = [ $(ps).get <variant> ] ;
    .info "  variant=" $(variant) ;

    local link = [ $(ps).get <link> ] ;
    .info "  link= " $(link) ;

    local runtime-link = [ $(ps).get <runtime-link> ] ;
    .info "  runtime-link=" $(runtime-link) ;

    local runtime-debugging = [ $(ps).get <runtime-debugging> ] ;
    .info "  runtime-debugging=" $(runtime-debugging) ;

    local address-model = [ $(ps).get <address-model> ] ;
    .info "  address-model=" $(address-model) ;

    local toolset = [ MATCH ^-(.*) : [ common.format-name <toolset> : "" : "" : $(ps) ] ] ;
    .info "  toolset=" $(toolset) ;

    local ftype = STATIC_LIB ;

    if $(link) = shared
    {
        if [ os.name ] = NT
        {
            ftype = IMPORT_LIB ;
        }
        else
        {
            ftype = SHARED_LIB ;
        }
    }

    local fname = [ boostcpp.tag $(name) : $(ftype) : $(ps) ] ;
    .info "  fname=" $(fname) ;

    print.text

        "# Generated by Boost $(version)"
        ""
        "if(Boost_DEBUG)"
        "  message(STATUS \"Found $(fname)\")"
        "endif()"
        ""
        : true ;

    print.text "# variant=$(variant)" "" : true ;

    if $(variant) = debug
    {
        print.text

            "if(NOT \"${Boost_USE_DEBUG_LIBS}\" STREQUAL \"\" AND NOT Boost_USE_DEBUG_LIBS)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to NOT Boost_USE_DEBUG_LIBS\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(NOT \"${Boost_USE_RELEASE_LIBS}\" STREQUAL \"\" AND NOT Boost_USE_RELEASE_LIBS)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to NOT Boost_USE_RELEASE_LIBS\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    
    print.text "# link=$(link)" "" : true ;

    if $(link) = static
    {
        print.text

            "if(NOT Boost_USE_STATIC_LIBS)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to NOT Boost_USE_STATIC_LIBS\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(Boost_USE_STATIC_LIBS)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to Boost_USE_STATIC_LIBS\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    
    print.text "# runtime-link=$(runtime-link)" "" : true ;

    if $(runtime-link) = static
    {
        print.text

            "if(NOT Boost_USE_STATIC_RUNTIME)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to NOT Boost_USE_STATIC_RUNTIME\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(Boost_USE_STATIC_RUNTIME)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to Boost_USE_STATIC_RUNTIME\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    print.text "# runtime-debugging=$(runtime-debugging)" "" : true ;
#|
    if $(runtime-debugging) = "on"
    {
        print.text

            "if(NOT Boost_USE_DEBUG_RUNTIME)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to NOT Boost_USE_DEBUG_RUNTIME\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(Boost_USE_DEBUG_RUNTIME)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to Boost_USE_DEBUG_RUNTIME\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }
|#
    print.text "# address-model=$(address-model)" "" : true ;

    if $(address-model) = 32
    {
        print.text

            "if(CMAKE_SIZEOF_VOID_P EQUAL 8)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to CMAKE_SIZEOF_VOID_P EQUAL 8\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(CMAKE_SIZEOF_VOID_P EQUAL 4)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  skipped due to CMAKE_SIZEOF_VOID_P EQUAL 4\")"
            "  endif()"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    print.text "# toolset=$(toolset)" "" : true ;

    print.text

        "if(Boost_COMPILER AND NOT Boost_COMPILER STREQUAL \"$(toolset)\")"
        "  if(Boost_DEBUG)"
        "    message(STATUS \"  skipped due to NOT Boost_COMPILER STREQUAL $(toolset)\")"
        "  endif()"
        "  return()"
        "endif()"
        ""
        "message(STATUS \"  $(fname)\")"
        ""
        : true ;

    local lname = [ MATCH boost_(.*) : $(name) ] ;
    .info "  lname=" $(lname) ;

    local target = "Boost::$(lname)" ;
    .info "  target=" $(target) ;

    print.text "# Target file name: $(fname)" : true ;

    print.text

        "set_property(TARGET $(target) APPEND PROPERTY IMPORTED_CONFIGURATIONS $(variant:U))"
        "set_target_properties($(target) PROPERTIES"
        "  IMPORTED_LINK_INTERFACE_LANGUAGES_$(variant:U) CXX"
        "  IMPORTED_LOCATION_$(variant:U) \"${_IMPORT_PREFIX}/lib/$(fname)\""
        "  )"
        ""
        : true ;
}

# tag

rule tag ( name : type ? : property-set )
{
    #.info tag $(name) ":" $(type) ":" $(property-set) ;

    local link = [ $(property-set).get <link> ] ;
    #.info "tag: link is $(link)" ;

    local r = [ boostcpp.tag $(name) : STATIC_LIB : $(property-set) ] ;

    r = $(r:S=$(name:S)) ;
    r = $(r:B=$(r:B)-$(link)) ;

    #.info "tag: returning $(r)" ;

    return $(r) ;
}

# generate-cmake-variant

rule generate-cmake-variant ( project name : property-set : sources * )
{
    .info generate-cmake-variant $(name) ;

    local tag = [ tag $(name) : : $(property-set) ] ;

    #.info "generate-cmake-variant:" tag is $(tag) ;
    
    local result ;

    local a = [ new non-scanning-action : cmake-config.generate-cmake-variant- : $(property-set) ] ;
    
    result += [ new file-target $(tag) : : $(project) : $(a) ] ;

    return $(result) ;
}

# generate-cmake-config-

rule generate-cmake-config- ( target : sources * : properties * )
{
    .info generate-cmake-config- $(target) ":" $(sources) ;

    local ps = [ property-set.create $(properties) ] ;

    print.output $(target) ;

    local version = [ $(ps).get <version> ] ;
    .info "  version=" $(version) ;

    local name = [ $(ps).get <name> ] ;
    .info "  name=" $(name) ;

    local library-type = [ $(ps).get <library-type> ] ;
    .info "  library-type=" $(library-type) ;

    local lname = [ MATCH boost_(.*) : $(name) ] ;
    .info "  lname=" $(lname) ;

    local ltarget = "Boost::$(lname)" ;
    .info "  ltarget=" $(ltarget) ;
    
    local BOOST_VERSION_TAG = [ modules.peek boostcpp : BOOST_VERSION_TAG ] ;
    .info "  BOOST_VERSION_TAG=" $(BOOST_VERSION_TAG) ;

    local layout = [ modules.peek boostcpp : layout ] ;
    .info "  layout=" $(layout) ;

    local header-subdir = "" ;

    if $(layout) = versioned
    {
        header-subdir = /boost-$(BOOST_VERSION_TAG) ;
    }

    .info "  header-subdir=" $(header-subdir) ;

    print.output $(target) ;

    print.text

        "# Generated by Boost $(version)"
        ""
        "cmake_minimum_required(VERSION 3.5)"
        ""
        "if(TARGET $(ltarget))"
        "  return()"
        "endif()"
        ""
        "message(STATUS \"Found $(name)\")"
        ""
        "# Compute the installation prefix relative to this file."
        "get_filename_component(_IMPORT_PREFIX \"${CMAKE_CURRENT_LIST_DIR}/../../../\" ABSOLUTE)"
        ""
        "# Create imported target $(ltarget)"
        "add_library($(ltarget) $(library-type) IMPORTED)"
        ""
        "set_target_properties($(ltarget) PROPERTIES"
        "  INTERFACE_INCLUDE_DIRECTORIES \"\${_IMPORT_PREFIX}/include$(header-subdir)\""
        ")"
        ""
        "# include(${CMAKE_CURRENT_LIST_DIR}/../BoostDetectToolset-$(version).cmake)"
        ""
        "if(Boost_DEBUG)"
        "  message(STATUS \"Scanning ${CMAKE_CURRENT_LIST_DIR}/lib$(name)-variant*.cmake\")"
        "endif()"
        ""
        "file(GLOB variants \"${CMAKE_CURRENT_LIST_DIR}/lib$(name)-variant*.cmake\")"
        ""
        "foreach(f IN LISTS variants)"
        "  if(Boost_DEBUG)"
        "    message(STATUS \"Including ${f}\")"
        "  endif()"
        "  include(${f})"
        "endforeach()"
        ""
        "unset(variants)"
        "unset(_IMPORT_PREFIX)"
        ""
        "include(CMakeFindDependencyMacro)"
        ""
        : true ;

    local ln = $(lname) ;

    if $(ln) = "prg_exec_monitor" || $(ln) = "test_exec_monitor" || $(ln) = "unit_test_framework"
    {
        ln = test ;
    }

    local deps = [ modules.peek cmake-config-dependencies : $(ln) ] ;

    if ! $(deps)
    {
        local ln2 = [ MATCH "([a-z]+)_.*" : $(ln) ] ;

        if $(ln2)
        {
            ln = $(ln2) ;
            deps = [ modules.peek cmake-config-dependencies : $(ln) ] ;
        }
    }

    .info "  ln=" $(ln) "deps=" $(deps) ;

    for dep in $(deps)
    {
        print.text

        "find_dependency(boost_$(dep) $(version) EXACT)"
        "set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_LINK_LIBRARIES Boost::$(dep))"
        ""
        : true ;
    }
}

# generate-cmake-config

rule generate-cmake-config ( project name : property-set : sources * )
{
    .info generate-cmake-config $(name) ;

    local pname = [ $(property-set).get <name> ] ;
    local version = [ $(property-set).get <version> ] ;
    local location = [ $(property-set).get <location> ] ;
    local library-type = [ $(property-set).get <library-type> ] ;

    local ps = [ property-set.create <name>$(pname) <version>$(version) <location>$(location) <library-type>$(library-type) ] ;

    local result ;

    local a = [ new non-scanning-action : cmake-config.generate-cmake-config- : $(ps) ] ;

    result += [ new file-target $(name) : : $(project) : $(a) ] ;

    return $(result) ;
}

# generate-cmake-config-version-

rule generate-cmake-config-version- ( target : sources * : properties * )
{
    .info generate-cmake-config-version- $(target) ":" $(sources) ;

    local ps = [ property-set.create $(properties) ] ;

    print.output $(target) ;

    local version = [ $(ps).get <version> ] ;
    .info "  version=" $(version) ;

    print.output $(target) ;

    print.text

        "# Generated by Boost $(version)"
        ""
        "set(PACKAGE_VERSION $(version))"
        ""
        "if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)"
        "  set(PACKAGE_VERSION_COMPATIBLE FALSE)"
        "else()"
        "  set(PACKAGE_VERSION_COMPATIBLE TRUE)"
        "  if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)"
        "    set(PACKAGE_VERSION_EXACT TRUE)"
        "  endif()"
        "endif()"
        ""
        : true ;
}

# generate-cmake-config-version

rule generate-cmake-config-version ( project name : property-set : sources * )
{
    .info generate-cmake-config-version $(name) ;

    local pname = [ $(property-set).get <name> ] ;
    local version = [ $(property-set).get <version> ] ;
    local location = [ $(property-set).get <location> ] ;

    local ps = [ property-set.create <name>$(pname) <version>$(version) <location>$(location) ] ;

    local result ;

    local a = [ new non-scanning-action : cmake-config.generate-cmake-config-version- : $(ps) ] ;

    result += [ new file-target $(name) : : $(project) : $(a) ] ;

    return $(result) ;
}

# lib

rule lib ( location : version : name )
{
    #.info cmake-config.lib $(name) ;

    location = $(location)/cmake/$(name)-$(version) ;

    local library-type = UNKNOWN ;

    if $(name) = boost_headers || $(name) = boost_math
    {
        library-type = INTERFACE ;
    }

    local reqs = <name>$(name) <version>$(version) <location>$(location) <library-type>$(library-type) ;

    local r ;

    r += [ generate $(name)-config.cmake : $(name) : <generating-rule>@generate-cmake-config $(reqs) ] ;
    r += [ generate $(name)-config-version.cmake : $(name) : <generating-rule>@generate-cmake-config-version $(reqs) ] ;

    if $(library-type) != INTERFACE
    {
        r += [ generate $(name)-variant.cmake : $(name) : <generating-rule>@generate-cmake-variant $(reqs) ] ;
    }

    return $(r) ;
}

rule libs ( target : location : version : name * )
{
    .info cmake-config.libs $(name) ;

    local configs ;

    for nm in $(name)
    {
        configs += [ lib $(location) : $(version) : $(nm) ] ;
    }

    alias $(target) : $(configs) ;
}
